# Review

<br>
 간단해 보였지만 간단한 부분이 끝나니 간단하지 않은 문제를 만날 수 있었습니다.    
 
처음에 최적화를 생각해보았을 때는 정해진 정답을 향해 간다고 생각했지만,  
최적화라는 것이 무조건적인 정답이 있는 것이 아니라는 것을 느꼈습니다.  
사용자가 어떤 작업을 많이 하는지와 개발자의 관점에 따라 방향이 정해질 수 있다고 생각이 들었습니다.  
<br>

## Team
 다른 분들의 접근 방식에 대해 배울 점이 많았고, 프로그래밍이 아닌 다른 부분에서도 배울 점이 많았습니다.  
django를 사용하는 분들이 개인적으로 주변에 없었는데 이번 기회에 django가 기반이 되는 코드 작성이 이루어져서  
설명이 이해가 더 잘되었습니다.

<br>
<br>


---
## BreadCrumbs
<br>

처음에는 단순히 사용자의 자취만 따라간다고 생각하여 브레드크럼 리스트를 주고받는 방식을 생각했습니다.  
첫번째 팀 회의를 통해 깨달은 것은 이미 만들어진 브레드크럼이 중간에 업데이트 된다는 사실이였고,   
결국 브레드크럼을 확인하려면 페이지 조회를 할 때 마다 백엔드에서 데이터를 받아와야 한다는 것을 알았습니다.  

다음날 회의에서 태완님의 완성도가 높은 구체적인 코드를 통해서 최적화의 요점을 잡을 수 있었습니다.    
읽기 작업의 최적화를 위한 브레드크럼 캐싱 테이블과 업데이트를 위한 DP,BFS 알고리즘을 구현하셨고   
이를 통해 인사이트를 얻을 수 있었습니다.  
<br>
#### Pagination
뒤늦게 생각났기에 구현까지 해보지 못했지만, 브레드크럼을 캐싱하여 저장한다면 페이지네이션을 적용해서  
캐싱한 브레드크럼의 길이를 제한하는 방식입니다.  

읽기 작업의 최적화가 브레드크럼 테이블의 캐싱이라면 DB 업데이트에 부담을 덜어줄 방법이라 생각했고,  
길이 제한을 환경변수로 지정해두면 서비스의 DB 상황에 따라 유동적인 대처도 가능합니다.  

최대 길이를 넘어가는 페이지간 관계에 대해서는 프론트엔드에서 현재 페이지의 최대 깊이까지만 제공하는 방식으로 해결해볼 수 있습니다.  

---

 처음엔 프레임워크나 ORM없이 진행되기에 어렵진 않지만 익숙하지도 않았다는 생각을 했다면  
지금은 그 덕분에 최적화와 그 접근 방식에 집중할 수 있는 과제였다는 생각이 듭니다.  
